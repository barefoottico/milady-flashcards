<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Milady Barber Flashcards (1‚Äì50)</title>
<style>
  /* THEME TOKENS ‚Äî dark defaults; light overrides below via [data-theme="light"] */
  :root{
    --bgGradStart:#0e1116; --bgGradEnd:#0b0e13;
    --card:#161a22; --soft:#1f2530; --ink:#e9edf5; --muted:#b6c0d4;
    --accent:#6ea8ff; --good:#34d399; --bad:#f87171; --focus:#93c5fd; --warn:#fbbf24;
    --border:rgba(255,255,255,.08); --border-strong:rgba(255,255,255,.12); --badgeBg:rgba(255,255,255,.12);
    --headerBg:rgba(15,17,21,.6);
    --btnBg:#e9edf5; --btnFg:#0c111a; /* default button */
    --shadow:0 10px 30px rgba(0,0,0,.30);
    --radius:18px;
  }
  html[data-theme="light"]{
    --bgGradStart:#f6f8fb; --bgGradEnd:#eef2f7;
    --card:#ffffff; --soft:#f3f6fb; --ink:#0f172a; --muted:#475569;
    --accent:#2563eb; --good:#059669; --bad:#dc2626; --focus:#2563eb; --warn:#d97706;
    --border:rgba(15,23,42,.10); --border-strong:rgba(15,23,42,.14); --badgeBg:rgba(15,23,42,.08);
    --headerBg:rgba(255,255,255,.75);
    --btnBg:#0f172a; --btnFg:#f8fafc;
    --shadow:0 10px 24px rgba(2,6,23,.10);
  }

  *{box-sizing:border-box}
  html,body{margin:0;height:100%}
  body{
    background:linear-gradient(180deg,var(--bgGradStart) 0%,var(--bgGradEnd) 100%);
    color:var(--ink);
    font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
  }
  header{
    position:sticky; top:0; z-index:10; backdrop-filter:saturate(1.2) blur(8px);
    background:var(--headerBg); border-bottom:1px solid var(--border);
  }
  .wrap{max-width:900px; margin:0 auto; padding:16px 20px}
  .row{display:flex; gap:12px; flex-wrap:wrap; align-items:center}
  h1{font-size:1.25rem; margin:0; letter-spacing:.2px}
  .pill{
    background:var(--soft); border:1px solid var(--border);
    padding:8px 12px; border-radius:999px; color:var(--muted); font-size:.9rem;
  }
  input[type="file"]{
    display:inline-block; color:var(--ink); background:var(--soft);
    border:1px dashed var(--border); padding:10px 12px; border-radius:12px;
  }

  main .panel{
    background:var(--card); border:1px solid var(--border);
    border-radius:var(--radius); box-shadow:var(--shadow); padding:20px;
  }
  .center{display:grid; place-items:center; min-height:58vh; text-align:center}
  .muted{color:var(--muted)}
  .cta{display:flex; gap:10px; flex-wrap:wrap; justify-content:center}

  /* Buttons */
  button{
    appearance:none; border:none; cursor:pointer; font-weight:600;
    background:var(--btnBg); color:var(--btnFg);
    padding:12px 16px; border-radius:12px;
    transition:transform .04s ease, box-shadow .2s ease, opacity .2s ease;
  }
  button:hover{transform:translateY(-1px)}
  button:active{transform:translateY(0)}
  button.ghost{
    background:transparent; color:var(--ink); border:1px solid var(--border);
  }
  button.primary{background:var(--accent); color:#00122b}
  html[data-theme="light"] button.primary{color:#eff6ff}
  button.good{background:var(--good); color:#07160f}
  button.bad{background:var(--bad); color:#210707}
  button.warn{background:var(--warn); color:#1e1606}
  button[disabled]{opacity:.6; cursor:not-allowed}
  button:focus-visible{outline:3px solid var(--focus); outline-offset:2px}

  /* Layout sections */
  .toolbar{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .spacer{flex:1}
  .mode-toggle{display:flex; gap:8px; background:var(--soft); padding:6px; border-radius:14px; border:1px solid var(--border)}
  .mode-toggle button{
    background:transparent; color:var(--muted); padding:8px 12px; border-radius:10px;
    border:1px solid transparent;
  }
  .mode-toggle button[aria-pressed="true"]{
    background:var(--accent); color:#00122b; border-color:transparent;
  }
  html[data-theme="light"] .mode-toggle button[aria-pressed="true"]{ color:#eff6ff }

  /* Card */
  .card{
    display:grid; gap:12px; background:var(--card);
    border:1px solid var(--border); border-radius:var(--radius); padding:18px;
  }
  .meta{display:flex; gap:10px; flex-wrap:wrap; align-items:center; color:var(--muted); font-size:.9rem}
  .qid{background:var(--badgeBg); border:1px solid var(--border-strong); padding:4px 8px; border-radius:999px; color:var(--ink)}
  .src{color:var(--muted)}
  .question{font-size:1.15rem}
  .options{display:grid; gap:10px}
  .opt{
    display:flex; gap:12px; align-items:center; width:100%;
    background:var(--soft); color:var(--ink); border:1px solid var(--border);
    border-radius:12px; padding:14px; text-align:left;
  }
  .opt .badge{
    width:28px; height:28px; border-radius:8px; display:grid; place-items:center;
    background:var(--badgeBg); color:var(--ink); font-weight:700; flex:0 0 28px;
    border:1px solid var(--border);
  }
  .opt[disabled]{opacity:.6; cursor:not-allowed}
  .opt.correct{outline:2px solid var(--good); background:color-mix(in oklab, var(--good) 12%, transparent)}
  .opt.wrong{outline:2px solid var(--bad); background:color-mix(in oklab, var(--bad) 12%, transparent)}
  .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:6px}
  .progress{color:var(--muted); font-size:.95rem}

  /* Results */
  .results h2{margin:.2rem 0 1rem 0}
  .score{
    display:flex; gap:12px; align-items:center; background:var(--soft);
    border:1px solid var(--border); border-radius:14px; padding:14px;
  }
  .missed{margin-top:16px; display:grid; gap:14px}
  .missed .miss{
    background:var(--soft); border:1px solid var(--border);
    border-radius:14px; padding:14px;
  }
  .miss .q{margin:.1rem 0 .5rem 0}
  .pair{display:flex; gap:10px; flex-wrap:wrap}
  .pair .tag{font-weight:700}
  .pair .ans{color:var(--ink)}

  /* Debug */
  .debug-toggle{margin-left:auto}
  #debugPanel{display:none; margin-top:10px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.9rem}
  #debugPanel pre{
    background:color-mix(in oklab, var(--soft) 70%, black 0%); color:var(--muted);
    border:1px solid var(--border); border-radius:12px; padding:12px; overflow:auto;
  }
  .show{display:block !important}
  .hidden{display:none !important}

  @media (min-width:720px){
    .question{font-size:1.25rem}
  }
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="row">
        <h1>Milady Barber Flashcards</h1>
        <span class="pill">Single-Page ‚Ä¢ No backend</span>
        <div class="spacer"></div>

        <!-- Theme toggle -->
        <button id="themeToggle" class="ghost" aria-pressed="false" title="Toggle color theme">‚òÄÔ∏è Light</button>

        <!-- Load CSV (always visible) -->
        <label for="csvInput" class="pill" aria-label="Load CSV">Load CSV</label>
        <input id="csvInput" type="file" accept=".csv" aria-label="Choose CSV file" />

        <!-- Mode toggle (disabled until CSV is loaded) -->
        <div class="mode-toggle" role="tablist" aria-label="Mode">
          <button id="modeOpen" role="tab" aria-pressed="false" disabled>Open Play</button>
          <button id="modeTest" role="tab" aria-pressed="false" disabled>Test Mode</button>
        </div>

        <button id="resetBtn" class="ghost" disabled title="Reset to mode selection">Reset</button>
        <button id="debugBtn" class="ghost debug-toggle" title="Toggle debug">üêû Debug</button>
      </div>
    </div>
  </header>

  <main class="wrap">
    <!-- Friendly preload screen -->
    <section id="screenPreload" class="panel center">
      <div>
        <h2>Please load dataset</h2>
        <p class="muted">Use the <b>Load CSV</b> control above and select<br>
          <code>mbf_review_questions_1_50 - mbf_review_questions_1_50.csv.csv</code>.
        </p>
        <div class="cta">
          <button class="primary" aria-describedby="csvHelp" onclick="document.getElementById('csvInput').click()">Load CSV</button>
          <span id="csvHelp" class="muted" aria-hidden="true">No server needed. Parses locally.</span>
        </div>
      </div>
    </section>

    <!-- Mode selection (after CSV loaded) -->
    <section id="screenModes" class="panel center hidden" aria-live="polite">
      <div>
        <h2>Choose a mode</h2>
        <p class="muted">Tap to begin. You can switch anytime.</p>
        <div class="cta" role="group" aria-label="Choose mode">
          <button id="startOpen" class="primary">Open Play</button>
          <button id="startTest" class="">Test Mode</button>
        </div>
      </div>
    </section>

    <!-- Open Play screen -->
    <section id="screenOpen" class="panel hidden" aria-live="polite">
      <div class="card" aria-labelledby="qTextOpen">
        <div class="meta">
          <span class="qid" id="metaOpenId">ID ‚Äî</span>
          <span class="src" id="metaOpenSource"></span>
        </div>
        <div id="qTextOpen" class="question"></div>
        <div id="optsOpen" class="options" role="group" aria-label="Options (view only)"></div>
        <div class="controls">
          <button id="flipBtn" class="ghost" aria-pressed="false">Flip</button>
          <button id="nextBtn" class="">Next</button>
          <span id="openProgress" class="progress"></span>
        </div>
      </div>
    </section>

    <!-- Test Mode screen -->
    <section id="screenTest" class="panel hidden" aria-live="polite">
      <div class="card" aria-labelledby="qTextTest">
        <div class="meta">
          <span class="qid" id="metaTestId">ID ‚Äî</span>
          <span class="src" id="metaTestSource"></span>
          <span class="spacer"></span>
          <span id="testProgress" class="progress"></span>
        </div>
        <div id="qTextTest" class="question"></div>
        <div id="optsTest" class="options" role="group" aria-label="Options (choose one)"></div>
      </div>
    </section>

    <!-- Results screen -->
    <section id="screenResults" class="panel hidden results" aria-live="polite">
      <h2>Results</h2>
      <div id="scoreBox" class="score"></div>
      <div class="controls" style="margin-top:14px">
        <button id="retakeBtn" class="primary">Retake Test (reshuffle)</button>
        <button id="backToModesBtn" class="ghost">Back to Modes</button>
      </div>
      <div id="missedWrap" class="missed"></div>
    </section>

    <!-- Debug -->
    <section id="debugPanel" class="panel">
      <h3 style="margin-top:0">Debug</h3>
      <pre id="debugPre">{}</pre>
    </section>
  </main>

<script>
/* ============
   Minimal CSV Parser (handles quotes, commas, CRLF)
   Returns array of objects keyed by header row.
   ============ */
function parseCSV(text){
  // Normalize newlines and strip BOM
  if (text.charCodeAt(0) === 0xFEFF) text = text.slice(1);
  let i=0, inQuotes=false, field='', row=[], rows=[];
  const pushField=()=>{ row.push(field); field=''; };
  const pushRow=()=>{ rows.push(row); row=[]; };

  while(i < text.length){
    const c = text[i];
    if(inQuotes){
      if(c === '"'){
        if(text[i+1] === '"'){ field += '"'; i++; } // escaped quote
        else { inQuotes = false; }
      }else{
        field += c;
      }
    }else{
      if(c === '"'){ inQuotes = true; }
      else if(c === ','){ pushField(); }
      else if(c === '\n'){ pushField(); pushRow(); }
      else if(c === '\r'){ /* ignore CR */ }
      else{ field += c; }
    }
    i++;
  }
  // flush last
  pushField(); pushRow();
  // remove any trailing empty rows
  while(rows.length && rows[rows.length-1].every(x => x === '')) rows.pop();

  if(rows.length === 0) return [];
  const header = rows.shift().map(h => h.trim());
  // map to objects
  const out = rows.map(r => {
    const o = {};
    header.forEach((h, idx) => { o[h] = (r[idx] ?? '').trim(); });
    return o;
  });
  return out;
}

/* ---- Auto-load config (set this to your CSV file in the repo root) */
const CSV_PATH = 'FINAL mbf_review_questions_1_50.csv';
// e.g. const CSV_PATH = 'FINAL mbf_review_questions_1_50.csv';

/* ============
   App State
   ============ */
const state = {
  loaded:false,
  mode:null,             // 'open' | 'test' | null
  questions:[],          // normalized rows
  order:[],              // array of indices into questions (shuffled per run)
  current:0,             // pointer into order
  flipped:false,         // Open Play flip state
  answers:new Map(),     // Test Mode: idxInQuestions -> {letter, ts}
  autoAdvanceMs: 350
};

function resetRunKeepData(){
  state.order = Array.from({length: state.questions.length}, (_,i)=>i);
  shuffle(state.order);
  state.current = 0;
  state.flipped = false;
  state.answers.clear();
}

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

/* ============
   Data Normalization & Validation
   ============ */
const REQUIRED_COLS = ["id","type","question","option_a","option_b","option_c","option_d","option_e","correct_options","source","topic"];

function normalizeRows(rawRows){
  // Validate required columns exist on first row
  const missingCols = REQUIRED_COLS.filter(k => !(k in rawRows[0]));
  if(missingCols.length){
    throw new Error("Missing columns in CSV: " + missingCols.join(", "));
  }

  // Map each row to canonical shape and filter out truly empty ids/questions
  const mapped = rawRows.map(r => {
    const options = [];
    const pushOpt = (letter, text) => {
      const t = (text ?? "").trim();
      if(t) options.push({letter, text:t});
    };
    pushOpt('A', r.option_a);
    pushOpt('B', r.option_b);
    pushOpt('C', r.option_c);
    pushOpt('D', r.option_d);
    pushOpt('E', r.option_e);

    // correct_options may contain one letter; we will take the first valid A-E for logic
    const corrLetters = (r.correct_options || "")
      .toUpperCase()
      .replace(/[^A-E]/g, '')
      .split('')
      .filter((v,i,arr)=>arr.indexOf(v)===i); // unique

    return {
      id: (r.id ?? "").trim(),
      type: (r.type ?? "").trim(),
      question: (r.question ?? "").trim(),
      options,                      // only non-empty options (A‚ÄìE)
      correctLetters: corrLetters.length ? corrLetters : [],
      correctPrimary: corrLetters.find(l => options.some(o=>o.letter===l)) || null,
      source: (r.source ?? "").trim(),
      topic: (r.topic ?? "").trim()
    };
  }).filter(obj => obj.id && obj.question);

  return mapped;
}

function validateRow(row){
  if(!row) return "That question is not in the provided list.";
  if(!row.id || !row.question) return "That question is not in the provided list.";
  if(!row.options.length) return "That question is not in the provided list.";
  if(!row.correctPrimary) return "That question is not in the provided list.";
  return null; // valid
}

/* ---- Auto-load from repo root (GitHub Pages, Netlify, etc.) */
async function tryAutoLoadCSV() {
  try {
    const res = await fetch(CSV_PATH, { cache: 'no-store' });
    if (!res.ok) return;                    // file not present? bail out
    const text = await res.text();
    const raw = parseCSV(text);
    const rows = normalizeRows(raw);
    if (!rows.length) return;

    state.questions = rows;
    state.loaded = true;
    resetRunKeepData();

    // Enable UI same as manual loader
    [el.modeOpen, el.modeTest, el.resetBtn].forEach(b => b.disabled = false);
    el.modeOpen.setAttribute('aria-pressed','false');
    el.modeTest.setAttribute('aria-pressed','false');

    showScreen('modes');
    renderDebug();
  } catch (_) {
    // network/404? it's fine ‚Äî user can still use the file picker
  }
}

/* ============
   DOM Refs
   ============ */
const el = {
  csvInput: document.getElementById('csvInput'),
  screenPreload: document.getElementById('screenPreload'),
  screenModes: document.getElementById('screenModes'),
  screenOpen: document.getElementById('screenOpen'),
  screenTest: document.getElementById('screenTest'),
  screenResults: document.getElementById('screenResults'),

  modeOpen: document.getElementById('modeOpen'),
  modeTest: document.getElementById('modeTest'),
  startOpen: document.getElementById('startOpen'),
  startTest: document.getElementById('startTest'),
  resetBtn: document.getElementById('resetBtn'),

  // Theme
  themeToggle: document.getElementById('themeToggle'),

  // Open Play
  qTextOpen: document.getElementById('qTextOpen'),
  optsOpen: document.getElementById('optsOpen'),
  metaOpenId: document.getElementById('metaOpenId'),
  metaOpenSource: document.getElementById('metaOpenSource'),
  flipBtn: document.getElementById('flipBtn'),
  nextBtn: document.getElementById('nextBtn'),
  openProgress: document.getElementById('openProgress'),

  // Test Mode
  qTextTest: document.getElementById('qTextTest'),
  optsTest: document.getElementById('optsTest'),
  metaTestId: document.getElementById('metaTestId'),
  metaTestSource: document.getElementById('metaTestSource'),
  testProgress: document.getElementById('testProgress'),

  // Results
  scoreBox: document.getElementById('scoreBox'),
  missedWrap: document.getElementById('missedWrap'),
  retakeBtn: document.getElementById('retakeBtn'),
  backToModesBtn: document.getElementById('backToModesBtn'),

  // Debug
  debugBtn: document.getElementById('debugBtn'),
  debugPanel: document.getElementById('debugPanel'),
  debugPre: document.getElementById('debugPre')
};

/* ============
   Event Wiring
   ============ */
el.csvInput.addEventListener('change', handleCSVLoad);
el.startOpen.addEventListener('click', () => switchMode('open'));
el.startTest.addEventListener('click', () => switchMode('test'));
el.modeOpen.addEventListener('click', () => switchMode('open'));
el.modeTest.addEventListener('click', () => switchMode('test'));
el.resetBtn.addEventListener('click', resetToModeSelection);

// Theme toggle
el.themeToggle.addEventListener('click', toggleTheme);

// Open Play controls
el.flipBtn.addEventListener('click', () => {
  if(!state.loaded || state.mode!=='open') return;
  state.flipped = !state.flipped;
  el.flipBtn.setAttribute('aria-pressed', String(state.flipped));
  renderOpenCard();
});
el.nextBtn.addEventListener('click', nextOpen);

// Results
el.retakeBtn.addEventListener('click', () => { startTestRun(true); });
el.backToModesBtn.addEventListener('click', () => { showScreen('modes'); });

// Debug
el.debugBtn.addEventListener('click', () => {
  el.debugPanel.classList.toggle('show');
  renderDebug();
});

/* ============
   CSV Loading
   ============ */
function handleCSVLoad(){
  const file = el.csvInput.files?.[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    try{
      const text = String(e.target.result || "");
      const raw = parseCSV(text);
      if(!raw.length) throw new Error("CSV appears empty.");
      const rows = normalizeRows(raw);
      if(!rows.length) throw new Error("No valid rows found.");
      state.questions = rows;
      state.loaded = true;
      resetRunKeepData();

      // Enable UI
      [el.modeOpen, el.modeTest, el.resetBtn].forEach(b=>b.disabled=false);
      el.modeOpen.setAttribute('aria-pressed','false');
      el.modeTest.setAttribute('aria-pressed','false');

      showScreen('modes');
      renderDebug();
    }catch(err){
      alert("CSV error: " + err.message);
      console.error(err);
      state.loaded = false;
      state.questions = [];
      showScreen('preload');
    }
  };
  reader.onerror = () => alert("Failed to read file.");
  reader.readAsText(file);
}

/* ============
   Screen Routing
   ============ */
function showScreen(which){
  [el.screenPreload, el.screenModes, el.screenOpen, el.screenTest, el.screenResults].forEach(s=>s.classList.add('hidden'));
  if(which==='preload') el.screenPreload.classList.remove('hidden');
  else if(which==='modes') el.screenModes.classList.remove('hidden');
  else if(which==='open') el.screenOpen.classList.remove('hidden');
  else if(which==='test') el.screenTest.classList.remove('hidden');
  else if(which==='results') el.screenResults.classList.remove('hidden');
}

function switchMode(mode){
  if(!state.loaded){ showScreen('preload'); return; }
  if(mode==='open'){
    state.mode = 'open';
    el.modeOpen.setAttribute('aria-pressed','true');
    el.modeTest.setAttribute('aria-pressed','false');
    startOpenRun();
  }else if(mode==='test'){
    state.mode = 'test';
    el.modeOpen.setAttribute('aria-pressed','false');
    el.modeTest.setAttribute('aria-pressed','true');
    startTestRun(true);
  }
  renderDebug();
}

function resetToModeSelection(){
  if(!state.loaded){ showScreen('preload'); return; }
  state.mode = null;
  el.modeOpen.setAttribute('aria-pressed','false');
  el.modeTest.setAttribute('aria-pressed','false');
  resetRunKeepData();
  showScreen('modes');
  renderDebug();
}

/* ============
   OPEN PLAY MODE
   ============ */
function startOpenRun(){
  resetRunKeepData();
  showScreen('open');
  renderOpenCard();
}

function renderOpenCard(){
  const idxQ = state.order[state.current];
  const row = state.questions[idxQ];
  const invalid = validateRow(row);
  if(invalid){
    el.metaOpenId.textContent = "ID ‚Äî";
    el.metaOpenSource.textContent = "";
    el.qTextOpen.textContent = invalid;
    el.optsOpen.innerHTML = "";
    el.openProgress.textContent = "";
    return;
  }

  el.metaOpenId.textContent = `ID ${row.id}`;
  el.metaOpenSource.textContent = row.source ? `Source: ${row.source}` : "";
  el.qTextOpen.textContent = row.question;

  el.optsOpen.innerHTML = "";
  row.options.forEach(opt => {
    const b = document.createElement('button');
    b.className = 'opt';
    b.type = 'button';
    b.disabled = true;
    b.setAttribute('aria-disabled','true');

    const badge = document.createElement('span');
    badge.className = 'badge'; badge.textContent = opt.letter;
    const span = document.createElement('span');
    span.textContent = opt.text;
    b.appendChild(badge); b.appendChild(span);

    if(state.flipped && opt.letter === row.correctPrimary){
      b.classList.add('correct');
      b.setAttribute('aria-label', 'Correct answer');
    }else{
      b.classList.remove('correct');
    }
    el.optsOpen.appendChild(b);
  });

  el.openProgress.textContent = `Card ${state.current+1} of ${state.order.length}`;
}

function nextOpen(){
  state.current++;
  state.flipped = false;
  el.flipBtn.setAttribute('aria-pressed','false');

  if(state.current >= state.order.length){
    resetRunKeepData();
  }
  renderOpenCard();
}

/* ============
   TEST MODE
   ============ */
function startTestRun(reshuffle=false){
  if(reshuffle) resetRunKeepData();
  state.answers.clear();
  showScreen('test');
  renderTestCard();
}

function renderTestCard(){
  if(state.current >= state.order.length){
    showResults();
    return;
  }
  const idxQ = state.order[state.current];
  const row = state.questions[idxQ];
  const invalid = validateRow(row);
  if(invalid){
    state.current++;
    renderTestCard();
    return;
  }

  el.metaTestId.textContent = `ID ${row.id}`;
  el.metaTestSource.textContent = row.source ? `Source: ${row.source}` : "";
  el.testProgress.textContent = `Card ${state.current+1} of ${state.order.length}`;

  el.qTextTest.textContent = row.question;
  el.optsTest.innerHTML = "";

  row.options.forEach(opt => {
    const btn = document.createElement('button');
    btn.className = 'opt';
    btn.type = 'button';
    btn.dataset.letter = opt.letter;
    btn.setAttribute('aria-label', `Choose option ${opt.letter}`);

    const badge = document.createElement('span');
    badge.className = 'badge'; badge.textContent = opt.letter;
    const span = document.createElement('span');
    span.textContent = opt.text;
    btn.appendChild(badge); btn.appendChild(span);

    btn.addEventListener('click', () => {
      lockChoices(el.optsTest);
      state.answers.set(idxQ, { letter: opt.letter, ts: Date.now() });
      setTimeout(() => {
        state.current++;
        renderTestCard();
      }, state.autoAdvanceMs);
    });

    el.optsTest.appendChild(btn);
  });

  renderDebug();
}

function lockChoices(container){
  const children = Array.from(container.querySelectorAll('.opt'));
  children.forEach(b => b.disabled = true);
}

/* ============
   RESULTS
   ============ */
function showResults(){
  showScreen('results');

  let correct = 0;
  const missed = [];
  for(const idxQ of state.order){
    const row = state.questions[idxQ];
    const pick = state.answers.get(idxQ);
    const chosen = pick?.letter || null;
    const isRight = !!chosen && chosen === row.correctPrimary;
    if(isRight) correct++;
    else missed.push({ row, chosen });
  }
  const total = state.order.length;
  const pct = Math.round((correct / total) * 100);

  el.scoreBox.innerHTML = `
    <div style="font-size:1.25rem; font-weight:800">${pct}%</div>
    <div class="muted">You scored <b>${correct}</b> / ${total}</div>
  `;

  el.missedWrap.innerHTML = "";
  if(missed.length === 0){
    const div = document.createElement('div');
    div.className = 'miss'; div.innerHTML = `<div class="q"><b>Perfect!</b> You didn‚Äôt miss any questions.</div>`;
    el.missedWrap.appendChild(div);
  }else{
    missed.forEach(({row, chosen}) => {
      const your = getLetterAndText(row, chosen);
      const corr = getLetterAndText(row, row.correctPrimary);
      const item = document.createElement('div');
      item.className = 'miss';
      item.innerHTML = `
        <div class="meta"><span class="qid">ID ${row.id}</span> <span class="src">${row.source ? "Source: "+row.source : ""}</span></div>
        <div class="q">${escapeHTML(row.question)}</div>
        <div class="pair"><span class="tag">Your answer:</span> <span class="ans">${your}</span></div>
        <div class="pair"><span class="tag">Correct:</span> <span class="ans">${corr}</span></div>
      `;
      el.missedWrap.appendChild(item);
    });
  }

  renderDebug();
}

function getLetterAndText(row, letter){
  if(!letter) return `<i>None</i>`;
  const found = row.options.find(o => o.letter === letter);
  if(!found) return `${letter}`;
  return `<b>${letter}</b> ‚Äî ${escapeHTML(found.text)}`;
}

function escapeHTML(str){
  return String(str).replace(/[&<>"']/g, m => ({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[m]));
}

/* ============
   THEME ‚Äî persistent light/dark with OS-pref fallback
   ============ */
function applyTheme(theme){
  const root = document.documentElement;
  root.setAttribute('data-theme', theme);
  const isLight = theme === 'light';
  el.themeToggle.setAttribute('aria-pressed', String(isLight));
  el.themeToggle.textContent = isLight ? 'üåô Dark' : '‚òÄÔ∏è Light';
  el.themeToggle.title = isLight ? 'Switch to dark mode' : 'Switch to light mode';
  try{ localStorage.setItem('mbf_theme', theme); }catch(e){}
}
function toggleTheme(){
  const current = document.documentElement.getAttribute('data-theme') || 'dark';
  applyTheme(current === 'dark' ? 'light' : 'dark');
}
function initTheme(){
  let saved = null;
  try{ saved = localStorage.getItem('mbf_theme'); }catch(e){}
  if(saved === 'light' || saved === 'dark'){
    applyTheme(saved);
  }else{
    const prefersLight = window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;
    applyTheme(prefersLight ? 'light' : 'dark');
  }
}

/* ============
   Utilities & Debug
   ============ */
function renderDebug(){
  const idxQ = state.order[state.current] ?? null;
  const row = idxQ!=null ? state.questions[idxQ] : null;
  const remain = state.order.length - state.current;
  const debugObj = {
    loaded: state.loaded,
    mode: state.mode,
    currentIndex: state.current,
    currentQuestionId: row?.id ?? null,
    remainingCount: remain,
    lastAnswerForCurrent: idxQ!=null ? state.answers.get(idxQ) ?? null : null,
    totalCards: state.order.length,
    theme: document.documentElement.getAttribute('data-theme')
  };
  el.debugPre.textContent = JSON.stringify(debugObj, null, 2);
}

/* Keyboard niceties (Enter on focused option triggers click) */
document.addEventListener('keydown', (e) => {
  if((e.key === 'Enter' || e.key === ' ') && document.activeElement?.tagName === 'BUTTON'){
    document.activeElement.click();
    e.preventDefault();
  }
});

/* ============
   Init
   ============ */
function init(){
  initTheme();
  // Try to auto-load; if we can't, fall back to the preload screen
  tryAutoLoadCSV().then(() => {
    if (!state.loaded) showScreen('preload');
  });
}
init();
</script>
</body>
</html>
